import tensorflow as tf
from tensorflow.keras import layers, models
import numpy as np


split_ratio = 0.8
num_samples = len(X)
split_index = int(num_samples * split_ratio)

indices = np.random.permutation(num_samples)
train_indices, test_indices = indices[:split_index], indices[split_index:]

X_train, X_test = X[train_indices], X[test_indices]
y_train, y_test = y[train_indices], y[test_indices]

model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape= ?), #expects a tuple format. I put (None,None,None) so the layer dynamically get the size so don't give bad info
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(128, (3, 3), activation='relu'),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(1, activation='sigmoid')  # I chose sigmod function here hope it is not wrong choice
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

model.fit(X_train, y_train, epochs=10, validation_data=(X_test, y_test))

test_loss, test_accuracy = model.evaluate(X_test, y_test, verbose=0) #We don't need verbose =1 or 2

model.save() #fill in

